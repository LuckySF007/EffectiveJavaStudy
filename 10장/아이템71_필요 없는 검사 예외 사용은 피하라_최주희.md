# 아이템71.필요 없는 검사 예외 사용은 피하라

## 검사 예외를 제대로 활용하면

검사 예외를 제대로 활용하면 API와 프로그램의 질을 높임 (검사 예외는 처리하여 안전성을 높일 수 있기 때문)

<br>

## 검사 예외를 과하게 사용하면

- 검사 예외는 호출자가 처리해야하는 강제성을 지니기 때문에 부담을 주게 된다.
- 검사 예외를 던지는 메서드는 스트림 안에서 직접 사용할 수 없어서 [아이템 45~48] 부담을 주게 된다.
- 특히, 메서드가 단 하나의 검사 예외만 던질 때 부담이 큼
    - 그 예외 하나 때문에 API 사용자는 try블록을 추가하고 스트림에서 사용하지 못하게 됨
    - 이런 상황에선 검사예외를 안 던질 방법이 없는지 고민해보자

<br>

## 검사 예외 회피 방법

1) Optional [아이템 55]

- 적절한 결과 타입을 담은 옵셔널은 반환하는 것이 검사 예외를 회피하는 가장 쉬운 방법
- 검사 예외를 던지는 대신 단순히 빈 옵셔널 반환하면 됨
- 그러나 이 방식은 예외 발생 이유에 대한 부가정보를 담을 수 없다는 단점이 있음

<br>

2) 검사 예외를 던지는 메서드를 2개로 쪼개 비검사 예외로 바꾸기

```java
// 검사 예외를 던지는 메서드 - 리팩토링 전
try {
	obj.action(args);
} catch (TheCheckedException e) {
	... // 예외 처리
}
```

```java
// 상태 검사 메서드와 비검사 예외를 던지는 메서드 - 리팩토링 후 (더 유연함)
if(obj.actionPermitted(args)){
	obj.action(args);
} else {
	... // 예외 처리
}
```

- 모든 상황에서 이 리팩터링을 할 수 있는 것은 아니다.
- 또한, 상태 검사 메서드의 단점도 그대로 적용됨 [아이템 69]
    - 외부 동기화 없이 여러 스레드가 동시에 접근할 수 있거나 외부 요인에 의해 상태가 변할 수 있다면 이 리팩터링은 적절하지 않음
    - 상태 검사 메서드(actionPermitted)가 상태 의존적 메서드(action)의 작업 일부를 중복 수행한다면 성능 손해이므로, 이 리팩터링이 적절치 않을 수 있음

<br>

## 결론

- 꼭 필요한 곳에만 사용한다면 검사 예외는 안전성을 높여주지만, 남용하면 사용자에게 큰 부담을 준다.
- API 호출자가 예외 상황에서 복구할 방법이 없다면 비검사 예외를 던지자.
- 복구가 가능하고 API 호출자가 그 처리를 하길 바란다면 옵셔널 반환을 먼저 고민해보자.
    - 옵셔널만으로 상황 처리에 충분한 정보를 줄 수 없을 때만 검사 예외를 던지자.