# 아이템84.프로그램의 동작을 스레드 스케줄러에 기대지말라

## **스레드 스케줄러**

여러 스레드가 실행중이면 운영체제의 스레드 스케줄러가 어떤 스레드를 얼마나 오래 실행할지 정한다.

운영체제는 모두 공정하게 수행하지만 구체적인 운영정책은 운영체제마다 다를 수 있다.

이 정책에 좌지우지 되지 않아야 좋은 프로그램이다. 

정확성이나 성능이 스레드 스케줄러에 따라 달라지는 프로그램은 다른 플랫폼에 이식하기 어렵다.

<br>

## **실행 가능한 스레드 수를 적게 유지하는 방법**

실행 가능한 스레드의 평균적인 수를 프로세서 수보다 지나치게 많아지지 않도록 해야한다.

1) 스레드는 당장 처리해야할 작업이 없다면 실행돼서는 안된다.

- 스레드 풀 크기를 적절히 설정하고 작업은 짧게 유지해야하나, 너무 짧으면 오히려 분배 부담이 늘어나 성능이 떨어진다.
- 바쁜 대기(busy waiting) 상태가 되면 안된다.

> busy waiting : 공유 객체의 상태가 바뀔 때까지 계속해서 검사하는 것 (프로세서에 큰 부담을 줌)
> 

```java
// 바쁜 대기 버전 CountDownLatch 구현
public class SlowCountDownLatch {
	private int count;
	
	public SlowCountDownLatch(int count) {
		if (count < 0)
			throw new IllegalArgumentException(count + " < 0");
		this.count = count;
	 }
	
	public void await() { // 바쁜 대기 중
		while (true) {
			synchronized(this) {
				if (count == 0)
					return;
	     }
	   }
	 }

	public synchronized void countDown() {
	if count != 0)
	      count--;
	  }
}
```

<br>

## **주의사항**

1) Thread.yield 를 사용하지 말자.

- 특정 스레드가 다른 스레드들과 비교해 CPU 시간을 충분히 얻지 못해 간신히 돌아가는 프로그램을 보더라도 Thread.yield로 고쳐보려는 유혹을 떨쳐내자.
- 증상은 호전될 수 있으나 이식성이 떨어지고, 테스트 할 수단도 없다.
- 차라리 애플리케이션 구조를 바꿔 동시 실행 가능 스레드 수가 적어지도록 하자.

2) 스레드 우선순위를 조절하지 말자.

- 스레드 우선순위는 자바에서 이식성이 가장 나쁜 특성
- 잘 돌아가는 프로그램의 품질을 높이기 위해 스레드 몇개의 우선순위를 조절하는 것은 드물게 사용
- 그러나 심각한 응답 불가 문제를 스레드 우선순위로 고치려하는건 비합리적

<br>

## **결론**

프로그램의 동작을 스레드 스케줄러에 기대지 말자.

견고성과 이식성을 해친다.

Thread.yield와 스레드 우선순위에 의존해서도 안된다.

스레드 우선순위로 프로그램을 고치는 용도로 사용해서는 절대 안된다.