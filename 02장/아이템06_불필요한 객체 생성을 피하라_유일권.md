# ITEM 06. **불필요한 객체 생성을 피하라.**

## **객체의 재사용**
---

같은 기능의 객체를 매번 생성하기보다 객체 하나를 재사용하는 편이 나을 때가 많다.  

불변 객체는 언제든지 재사용이 가능하다.  

정적 팩터리 메서드를 사용하여 불필요한 객체 생성을 막을 수도 있다.  
ex) `Boolean.valueOf(String)` 등..

```java
String s = new String("bikini");        //따라하지 말것.
String s = "bikini";                    //👙
```

두 코드의 차이점은 첫 문장은 실행될 때마다 `String` 인스턴스를 새로 만든다.  
하지만 2번째 문장은 하나의 `String` 인스턴스를 사용하므로 같은 가상 머신 안에서 같은 문자열을 사용하는 모든 코드가 같은 객체를 재사용함이 보장된다.

생성 비용이 아주 비싼 객체들도 여럿 존재한다. 이럴 경우 캐싱하여 재사용을 권한다. 아래에 예시를 보자.

```java
/*      문자열이 유효한 로마 숫지인지 확인하는 메서드     */
//1. 반복하여 사용하기에는 적합하지 않다.
static boolean isRomanNumeralSlow(String s) {
    return s.matches("^(?=.)M*(C[MD]|D?C{0,3})"
            + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
}

//2. Pattern 인스턴스를 클래스 초기화 과정에 미리 캐싱해두고, 재사용 하였다.
public class RomanNumerals {
    private static final Pattern ROMAN = Pattern.compile(
        "^(?=.)M*(C[MD]|D?C{0,3})"
            + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");

    static boolean isRomanNumeralFast(String s) {
        return ROMAN.matcher(s).matches();
    }
}
```

### **재사용 유의사항**

어댑터는 실제 작업은 뒷단 객체에 위임하고, 자신은 제2의 인터페이스 역할을 해주는 객체이다. 즉 뒷단 객체 하나당 어댑터 하나씩만 만들어지면 충분하다.  

`Map` 인터페이스의 `keySet` 메서드는 `Map` 객체 안의 키 전부를 담은 `Set` 뷰를 반환한다.  
`keySet` 을 호출할 때마다 새로운 `Set` 인스턴스가 생성되는 것이 아니라 같은 `Set` 인스턴스를 반환할 지도 모른다.  
즉 반환한 객체 중 하나를 수정하면 다른 모든 객체가 따라서 바뀐다. 모두 똑같은 `Map` 인스턴스를 대변하기 때문이다.

### **오토박싱**

오토박싱은 프로그래머가 기본 타입과, 박싱된 기본 타입을 섞어 쓸 때 자동으로 상호 변환해주는 기술이다. 이는 기본 타입과, 박싱된 기본 타입의 구분을 흐려주지만, 완전히 없애주지는 않는다. 

아래 예제를 보자.
```java
/*     모든 양의 정수의 총합을 계산하는 메서드     */
private static long sum() {
    Long sum = 0L;
    for(long i=0; i <=Integer.MAX_VALUE; i++)
        sum += i;

    return sum;
}
```
`sum` 변수를 `Long` 으로 선언하여 불필욯나 `Long` 인스턴스가 $2^{31}$개가 만들어졌다. 

**박싱된 기본 타입보다는 기본 타입을 사용하고, 의도치 않은 오토박싱이 숨어들지 않도록 주의하자.**

## **총정리**
"불필요한 객체 생성을 피하라"는 것이 "객체 생성은 비싸니 피해야 한다"로 오해하면 안된다. 

아주 무거운 객체가 아닌 다음에야 객체 생성을 피하려고 객체 풀(pool)을 만들지는 말자. 요즘 JVM의 가비지 컬렉터는 상당히 잘 최적화 되어있어 가벼운 객체를 다룰때는 훨씬 빠르다.

방어적 복사(Item. 50)과 대조적인데, 방어적 복사가 필요한 상황에서 객체를 재사용했을 때의 피해가, 필요 없는 객체를 반복 생성했을 떄의 피해보다 훨씬 거 크다.  
방어적 복사에 실패하면 버그와, 보안 구멍으로 이어지지만, 불필요한 객체 생성은 그저 코드 형태와 성능에만 영향을 주기 때문이다.